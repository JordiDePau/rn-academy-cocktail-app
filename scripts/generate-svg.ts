// // Script to generate illustration/icon components from SVG files and create an index file
//
// import { exec } from 'child_process';
// import { mkdir, readdir, readFile, writeFile } from 'fs/promises';
// import { dirname, join } from 'path';
// import { optimize } from 'svgo';
// import { promisify } from 'util';
//
// const execAsync = promisify(exec);
//
// const SVG_EXTENSION = '.svg';
//
// // Get script location and determine root directory
// const scriptPath = __filename;
// const scriptDirectory = dirname(scriptPath);
// const rootDirectory = join(scriptDirectory, '..');
//
// // Convert kebab-case to camelCase (e.g. "my-icon.svg" -> "myIcon")
// const toCamelCase = (file: string) =>
//   file.replace(new RegExp(`\\${SVG_EXTENSION}$`), '').replace(/-(\w)/g, (_, c) => c.toUpperCase());
//
// // Get base name without extension (e.g. "my-icon.svg" -> "my-icon")
// const getBaseName = (file: string) => file.replace(new RegExp(`\\${SVG_EXTENSION}$`), '');
//
// // Extract size and base name from icon filename
// const getIconInfo = (file: string) => {
//   const nameWithoutExt = getBaseName(file);
//   const match = nameWithoutExt.match(/^(.+)-(\d+)$/);
//
//   if (match && match[1] && match[2]) {
//     return {
//       baseName: match[1],
//       size: parseInt(match[2], 10),
//     };
//   }
//
//   return {
//     baseName: nameWithoutExt,
//     size: 24, // DEFAULT_ICON_SIZE
//   };
// };
//
// /**
//  * Optimizes an SVG file using SVGO
//  */
// const optimizeSvg = async (file: string, dir: string) => {
//   const content = await readFile(join(dir, file), 'utf8');
//   const newContent = optimize(content, {
//     plugins: [
//       {
//         name: 'preset-default',
//       },
//     ],
//   });
//   await writeFile(join(dir, file), newContent.data, 'utf8');
// };
//
// /**
//  * Generates optimized SVG components and creates an index file
//  */
// export const generateAppSvg = async (
//   type: 'illustration' | 'icon',
//   dir: string,
//   outputFilepath: string,
// ) => {
//   // Ensure output directory exists
//   await mkdir(dir, { recursive: true });
//
//   // Get all SVG files and sort them alphabetically
//   const files = (await readdir(dir)).filter((file) => file.endsWith(SVG_EXTENSION)).sort();
//
//   // Optimize all SVG files
//   await Promise.all(files.map((file) => optimizeSvg(file, dir)));
//
//   // For illustrations, handle dark mode variants
//   if (type === 'illustration') {
//     // Create a map of base names to their light and dark variants
//     const illustrationMap = new Map();
//
//     // Process all files in a single loop
//     files.forEach((file) => {
//       const isDarkVariant = file.endsWith('-dark.svg');
//       const baseName = isDarkVariant
//         ? getBaseName(file.replace('-dark.svg', ''))
//         : getBaseName(file);
//
//       const existing = illustrationMap.get(baseName) || { light: null, dark: null };
//
//       if (isDarkVariant) {
//         existing.dark = toCamelCase(file);
//       } else {
//         existing.light = toCamelCase(file);
//       }
//
//       illustrationMap.set(baseName, existing);
//     });
//
//     // Sort imports: group by base name, light version first, then dark version
//     const sortedImports = Array.from(illustrationMap.entries())
//       .sort(([a], [b]) => a.localeCompare(b)) // Sort by base name alphabetically
//       .flatMap(([baseName, variants]) => {
//         const imports = [];
//         if (variants.light) {
//           imports.push(`import ${variants.light} from './${baseName}.svg';`);
//         }
//         if (variants.dark) {
//           imports.push(`import ${variants.dark} from './${baseName}-dark.svg';`);
//         }
//         return imports;
//       })
//       .join('\n');
//
//     const illustrationEntries = Array.from(illustrationMap.entries())
//       .map(([baseName, variants]) => {
//         if (variants.light && variants.dark) {
//           return `'${baseName}': { light: ${variants.light}, dark: ${variants.dark} }`;
//         } else if (variants.light) {
//           return `'${baseName}': { light: ${variants.light}, dark: null }`;
//         } else {
//           return `'${baseName}': { dark: ${variants.dark}, light: null }`;
//         }
//       })
//       .join(',\n  ');
//
//     const output = `/*
// * CAUTION: This file is generated by \`pnpm run scripts:generate-app-svg\`
// * Do not edit this file manually. To add an illustration/icon, add an SVG file
// * to the illustrations or icons directory and re-run the script.
// */
// ${sortedImports}
//
// export const illustrationNames = {
//   ${illustrationEntries}
// } as const;
//
// /**
//  * Get the appropriate illustration based on the current theme
//  * @param name - The base name of the illustration (without -dark suffix)
//  * @param theme - The current theme ('light' | 'dark')
//  * @returns The SVG component for the appropriate theme
//  */
// export const getIllustration = (name: keyof typeof illustrationNames, theme: 'light' | 'dark') => {
//   const { light, dark } = illustrationNames[name];
//
//   if (theme === 'dark') {
//     return dark ?? light;
//   }
//
//   return light ?? dark;
// };
// `;
//
//     // Write the index file and format it with prettier
//     await writeFile(outputFilepath, output, 'utf8');
//     try {
//       await execAsync(`npx prettier --write ${outputFilepath} --ignore-unknown`);
//     } catch {
//       // Continue even if prettier fails
//       console.warn('Prettier formatting failed, but file was generated successfully');
//     }
//     console.log(
//       `Generated ${files.length} ${type}s (${illustrationMap.size} unique illustrations)`,
//     );
//     return true;
//   } else {
//     // For icons, group by base name and size
//     const iconMap = new Map();
//
//     // Process all icon files
//     files.forEach((file) => {
//       const { baseName, size } = getIconInfo(file);
//       const componentName = toCamelCase(file);
//
//       const existing = iconMap.get(baseName) || {};
//       existing[size] = componentName;
//       iconMap.set(baseName, existing);
//     });
//
//     const sortedImports = files
//       .map((name) => `import ${toCamelCase(name)} from './${name}';`)
//       .join('\n');
//
//     const iconEntries = Array.from(iconMap.entries())
//       .sort(([a], [b]) => a.localeCompare(b))
//       .map(([baseName, sizeMap]) => {
//         const sizeEntries = Object.entries(sizeMap)
//           .sort(([a], [b]) => parseInt(a, 10) - parseInt(b, 10))
//           .map(([size, component]) => `${size}: ${component}`)
//           .join(', ');
//         return `'${baseName}': { ${sizeEntries} }`;
//       })
//       .join(',\n  ');
//
//     const output = `/*
// * CAUTION: This file is generated by \`pnpm run scripts:generate-app-svg\`
// * Do not edit this file manually. To add an illustration/icon, add an SVG file
// * to the illustrations or icons directory and re-run the script.
// */
// ${sortedImports}
//
// export const ${type}Names = {
//   ${iconEntries}
// } as const;
// `;
//
//     // Write the index file and format it with prettier
//     await writeFile(outputFilepath, output, 'utf8');
//     try {
//       await execAsync(`npx prettier --write ${outputFilepath} --ignore-unknown`);
//     } catch {
//       // Continue even if prettier fails
//       console.warn('Prettier formatting failed, but file was generated successfully');
//     }
//     console.log(`Generated ${files.length} ${type}s (${iconMap.size} unique icons)`);
//     return true;
//   }
// };
//
// // Self-executing async function to run the generation process
// // Only run when not in test environment
// if (process.env.NODE_ENV !== 'test' && process.env.JEST_WORKER_ID === undefined) {
//   const illustrationsDir = join(rootDirectory, 'src/ui/assets/illustrations');
//   const illustrationsOutputFilepath = join(illustrationsDir, 'index.ts');
//
//   const iconsDir = join(rootDirectory, 'src/ui/assets/icons');
//   const iconsOutputFilepath = join(iconsDir, 'index.ts');
//
//   generateAppSvg('illustration', illustrationsDir, illustrationsOutputFilepath);
//   generateAppSvg('icon', iconsDir, iconsOutputFilepath);
// }
